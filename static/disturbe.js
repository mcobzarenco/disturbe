// Generated by CoffeeScript 1.7.1
var BOX_NONCE_BYTES, CIPHER_DECRYPT_INFO_FIELD, CIPHER_MESSAGE_FIELD, CIPHER_TRANSIENT_PKEY_FIELD, CIPHER_VERSION, CIPHER_VERSION_FIELD, CipherTextarea, ComposeMessage, CurveProfile, DECRYPT_INFO_MESSAGE_INFO_FIELD, DECRYPT_INFO_SENDER_FIELD, DecryptMessage, DisturbeApp, EncryptMessage, GeneratePrivateKey, HELLO_CLIENT_TRANSIENT_PKEY_FIELD, HELLO_PADDING_BYTES, HELLO_PADDING_FIELD, HELLO_URL, HELLO_ZEROS_BOX_FIELD, INITIATE_CLIENT_TRANSIENT_PKEY_FIELD, INITIATE_COOKIE_FIELD, INITIATE_URL, INITIATE_VOUCH_FIELD, InputField, KEY_BASE64_BYTES, KeyProfile, KeyProfileItem, MESSAGE_INFO_KEY_FIELD, MESSAGE_INFO_NONCE_FIELD, MINIMUM_PASSWORD_ENTROPY_BITS, Message, PublicKeyField, SCRYPT_L, SCRYPT_N, SCRYPT_P, SCRYPT_R, SERVER_DOMAIN_NAME, SERVER_PUBLIC_KEY, SecretKeyField, TAB_CLOUD, TAB_DECRYPT, TAB_ENCRYPT, VOUCH_CLIENT_PKEY_FIELD, VOUCH_DOMAIN_NAME_FIELD, VOUCH_MESSAGE_FIELD, VOUCH_TRANSIENT_KEY_BOX_FIELD, VerifyPassword, a, b64decode, b64encode, br, button, concatBuffers, credentialsToSecretKey, decode_utf8, decryptMessage, div, encode_utf8, encryptMessage, form, h1, h2, h3, h4, h5, h6, hr, i, input, label, li, nacl, option, p, scrypt, select, sendHello, sendInitiate, sendMessage, span, strong, textarea, toHex, ul, validPublicKey, _ref;

_ref = React.DOM, a = _ref.a, br = _ref.br, button = _ref.button, div = _ref.div, form = _ref.form, hr = _ref.hr, h1 = _ref.h1, h2 = _ref.h2, h3 = _ref.h3, h4 = _ref.h4, h5 = _ref.h5, h6 = _ref.h6, i = _ref.i, input = _ref.input, label = _ref.label, li = _ref.li, p = _ref.p, option = _ref.option, select = _ref.select, span = _ref.span, strong = _ref.strong, textarea = _ref.textarea, ul = _ref.ul;


/* Json CurveCP Protocol Constants */

SERVER_PUBLIC_KEY = 'kC_rSIO7t1ryhux1sn_LrtTrLyVZNd08BCXnSHQjgmA=';

SERVER_DOMAIN_NAME = 'curvech.at';

HELLO_URL = '/handshake/hello';

HELLO_PADDING_BYTES = 64;

HELLO_CLIENT_TRANSIENT_PKEY_FIELD = 'client_tpkey';

HELLO_PADDING_FIELD = 'padding';

HELLO_ZEROS_BOX_FIELD = 'zeros_box';

INITIATE_URL = '/handshake/initiate';

INITIATE_CLIENT_TRANSIENT_PKEY_FIELD = HELLO_CLIENT_TRANSIENT_PKEY_FIELD;

INITIATE_COOKIE_FIELD = 'cookie';

INITIATE_VOUCH_FIELD = 'vouch';

VOUCH_CLIENT_PKEY_FIELD = 'client_pkey';

VOUCH_TRANSIENT_KEY_BOX_FIELD = 'transient_key_box';

VOUCH_DOMAIN_NAME_FIELD = 'domain_name';

VOUCH_MESSAGE_FIELD = 'message';


/* Encryption Constants */

CIPHER_VERSION = 1;

CIPHER_VERSION_FIELD = 'version';

CIPHER_TRANSIENT_PKEY_FIELD = 'transient_pkey';

CIPHER_DECRYPT_INFO_FIELD = 'decrypt_info';

CIPHER_MESSAGE_FIELD = 'message';

DECRYPT_INFO_SENDER_FIELD = 'sender';

DECRYPT_INFO_MESSAGE_INFO_FIELD = 'message_info_box';

MESSAGE_INFO_KEY_FIELD = 'message_key';

MESSAGE_INFO_NONCE_FIELD = 'message_nonce';


/* Key Derivation Constants */

SCRYPT_N = Math.pow(2, 14);

SCRYPT_R = 8;

SCRYPT_P = 1;

SCRYPT_L = 32;

MINIMUM_PASSWORD_ENTROPY_BITS = 5;

BOX_NONCE_BYTES = 24;

KEY_BASE64_BYTES = 44;

nacl = nacl_factory.instantiate();

scrypt = scrypt_module_factory();

encode_utf8 = nacl.encode_utf8, decode_utf8 = nacl.decode_utf8;

credentialsToSecretKey = function(email, password) {
  var password_hash;
  password_hash = nacl.crypto_hash_string(password);
  return scrypt.crypto_scrypt(password_hash, encode_utf8(email), SCRYPT_N, SCRYPT_R, SCRYPT_P, SCRYPT_L);
};

concatBuffers = function(x, y) {
  var z;
  z = new Uint8Array(x.byteLength + y.byteLength);
  z.set(new Uint8Array(x), 0);
  z.set(new Uint8Array(y), x.byteLength);
  return z;
};

b64encode = function(arr) {
  var asString, base64Str, byte, _i, _len;
  asString = '';
  for (_i = 0, _len = arr.length; _i < _len; _i++) {
    byte = arr[_i];
    asString += String.fromCharCode(byte);
  }
  base64Str = btoa(asString);
  return base64Str.replace(/\+/g, '-').replace(/\//g, '_');
};

b64decode = function(base64Str) {
  return base64DecToArr(base64Str.replace(/-/g, '+').replace(/_/g, '/'));
};

toHex = function(arr) {
  var buf, elem, hexEncode, _i, _len;
  hexEncode = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
  buf = '';
  for (_i = 0, _len = arr.length; _i < _len; _i++) {
    elem = arr[_i];
    buf += hexEncode[(elem & 0xf0) >> 4];
    buf += hexEncode[elem & 0x0f];
  }
  return buf;
};

sendHello = function(transientKeys, success, error) {
  var nonce, noncedZerosBox, payload, serverPublicKey, zeros, zerosBox;
  serverPublicKey = b64decode(SERVER_PUBLIC_KEY);
  zeros = new Uint8Array(HELLO_PADDING_BYTES);
  nonce = nacl.crypto_box_random_nonce();
  zerosBox = nacl.crypto_box(zeros, nonce, serverPublicKey, transientKeys.boxSk);
  noncedZerosBox = concatBuffers(nonce, zerosBox);
  payload = {};
  payload[HELLO_CLIENT_TRANSIENT_PKEY_FIELD] = b64encode(transientKeys.boxPk);
  payload[HELLO_PADDING_FIELD] = b64encode(new Uint8Array(HELLO_PADDING_BYTES));
  payload[HELLO_ZEROS_BOX_FIELD] = b64encode(noncedZerosBox);
  return $.ajax({
    type: 'POST',
    url: HELLO_URL,
    data: JSON.stringify(payload),
    contentType: 'application/json',
    dataType: 'json',
    error: function(xhr) {
      return error(xhr);
    },
    success: function(data, status, xhr) {
      var cookie, cookie_box, cookie_box_cipher, cookie_box_nonce;
      cookie_box = b64decode(data.cookie_box);
      cookie_box_nonce = cookie_box.subarray(0, BOX_NONCE_BYTES);
      cookie_box_cipher = cookie_box.subarray(BOX_NONCE_BYTES);
      cookie = JSON.parse(decode_utf8(nacl.crypto_box_open(cookie_box_cipher, cookie_box_nonce, serverPublicKey, transientKeys.boxSk)));
      return success(b64decode(cookie.server_tpkey), cookie.cookie);
    }
  });
};

sendInitiate = function(userKeys, transientKeys, serverTPKey, cookie, message, success, error) {
  var noncedTransientKeyBox, noncedVouchBox, payload, serverPublicKey, transientKeyBox, transientKeyNonce, vouch, vouchBox, vouchBuffer, vouchNonce;
  serverPublicKey = b64decode(SERVER_PUBLIC_KEY);
  transientKeyNonce = nacl.crypto_box_random_nonce();
  transientKeyBox = nacl.crypto_box(transientKeys.boxPk, transientKeyNonce, serverPublicKey, userKeys.boxSk);
  noncedTransientKeyBox = concatBuffers(transientKeyNonce, transientKeyBox);
  vouch = {};
  vouch[VOUCH_CLIENT_PKEY_FIELD] = b64encode(userKeys.boxPk);
  vouch[VOUCH_TRANSIENT_KEY_BOX_FIELD] = b64encode(noncedTransientKeyBox);
  vouch[VOUCH_DOMAIN_NAME_FIELD] = SERVER_DOMAIN_NAME;
  vouch[VOUCH_MESSAGE_FIELD] = message;
  vouchBuffer = encode_utf8(JSON.stringify(vouch));
  vouchNonce = nacl.crypto_box_random_nonce();
  vouchBox = nacl.crypto_box(vouchBuffer, vouchNonce, serverTPKey, transientKeys.boxSk);
  noncedVouchBox = concatBuffers(vouchNonce, vouchBox);
  payload = {};
  payload[INITIATE_CLIENT_TRANSIENT_PKEY_FIELD] = b64encode(transientKeys.boxPk);
  payload[INITIATE_COOKIE_FIELD] = cookie;
  payload[INITIATE_VOUCH_FIELD] = b64encode(noncedVouchBox);
  return $.ajax({
    type: 'POST',
    url: INITIATE_URL,
    data: JSON.stringify(payload),
    contentType: 'application/json',
    dataType: 'json',
    error: error,
    success: function(data, status, xhr) {
      var response, response_box, response_box_cipher, response_box_nonce;
      response_box = b64decode(data.response);
      response_box_nonce = response_box.subarray(0, BOX_NONCE_BYTES);
      response_box_cipher = response_box.subarray(BOX_NONCE_BYTES);
      response = decode_utf8(nacl.crypto_box_open(response_box_cipher, response_box_nonce, serverTPKey, transientKeys.boxSk));
      return success(response);
    }
  });
};

sendMessage = function(userKeys, message, success, error) {
  var serverPublicKey, transientKeys;
  transientKeys = nacl.crypto_box_keypair();
  serverPublicKey = b64decode(SERVER_PUBLIC_KEY);
  return sendHello(transientKeys, function(serverTPKey, cookie) {
    return sendInitiate(userKeys, transientKeys, serverTPKey, cookie, message, success, error);
  }, error);
};

validPublicKey = function(key) {
  var error, valid;
  valid = false;
  try {
    if (typeof key === 'string') {
      key = b58decode(key);
    }
    if (key.length === nacl.crypto_box_PUBLICKEYBYTES) {
      valid = true;
    }
  } catch (_error) {
    error = _error;
    valid = false;
  }
  return valid;
};

encryptMessage = function(senderKeys, recipientPublicKeys, message) {
  var cipher, decryptInfo, decryptInfoBox, messageBox, messageHash, messageInfo, messageKey, messageNonce, nonce, recipientPublicKey, secretToRecipient, transientKeys, _i, _len, _ref1;
  secretToRecipient = function(transientKeys, senderKeys, recipientPublicKey, messageInfo) {
    var decryptInfo, decryptInfoBox, messageInfoBox, nonce;
    nonce = nacl.crypto_box_random_nonce();
    messageInfoBox = nacl.crypto_box(messageInfo, nonce, recipientPublicKey, senderKeys.boxSk);
    decryptInfo = {};
    decryptInfo[DECRYPT_INFO_SENDER_FIELD] = b58encode(senderKeys.boxPk);
    decryptInfo[DECRYPT_INFO_MESSAGE_INFO_FIELD] = b64encode(messageInfoBox);
    decryptInfo = encode_utf8(JSON.stringify(decryptInfo));
    decryptInfoBox = nacl.crypto_box(decryptInfo, nonce, recipientPublicKey, transientKeys.boxSk);
    return {
      nonce: nonce,
      decryptInfoBox: decryptInfoBox
    };
  };
  transientKeys = nacl.crypto_box_keypair();
  if (typeof message === 'string') {
    message = encode_utf8(message);
  }
  messageHash = nacl.crypto_hash(message);
  messageNonce = nacl.crypto_secretbox_random_nonce();
  messageKey = nacl.random_bytes(nacl.crypto_secretbox_KEYBYTES);
  messageBox = nacl.crypto_secretbox(message, messageNonce, messageKey);
  messageInfo = {};
  messageInfo[MESSAGE_INFO_KEY_FIELD] = b64encode(messageKey);
  messageInfo[MESSAGE_INFO_NONCE_FIELD] = b64encode(messageNonce);
  messageInfo = encode_utf8(JSON.stringify(messageInfo));
  cipher = {};
  cipher[CIPHER_VERSION_FIELD] = CIPHER_VERSION;
  cipher[CIPHER_TRANSIENT_PKEY_FIELD] = b58encode(transientKeys.boxPk);
  cipher[CIPHER_MESSAGE_FIELD] = b64encode(messageBox);
  decryptInfo = {};
  cipher[CIPHER_DECRYPT_INFO_FIELD] = decryptInfo;
  for (_i = 0, _len = recipientPublicKeys.length; _i < _len; _i++) {
    recipientPublicKey = recipientPublicKeys[_i];
    if (recipientPublicKey.length !== nacl.crypto_box_PUBLICKEYBYTES) {
      throw new Error("" + (b58encode(recipientPublicKey)) + " is not valid public key");
    }
    _ref1 = secretToRecipient(transientKeys, senderKeys, recipientPublicKey, messageInfo), nonce = _ref1.nonce, decryptInfoBox = _ref1.decryptInfoBox;
    decryptInfo[b64encode(nonce)] = b64encode(decryptInfoBox);
  }
  return JSON.stringify(cipher);
};

decryptMessage = function(userKeys, cipherText) {
  var GENERIC_ERROR, box, cipher, decryptInfo, decryptInfoNonce, error, messageInfo, messageInfoBox, messageKey, messageNonce, nonceBase64, plaintext, senderPublicKey, transientPublicKey, _ref1;
  GENERIC_ERROR = 'Could not decrypt message.';
  cipher = JSON.parse(cipherText);
  transientPublicKey = b58decode(cipher[CIPHER_TRANSIENT_PKEY_FIELD]);
  decryptInfo = null;
  decryptInfoNonce = null;
  _ref1 = cipher[CIPHER_DECRYPT_INFO_FIELD];
  for (nonceBase64 in _ref1) {
    box = _ref1[nonceBase64];
    try {
      decryptInfoNonce = b64decode(nonceBase64);
      decryptInfo = nacl.crypto_box_open(b64decode(box), decryptInfoNonce, transientPublicKey, userKeys.boxSk);
      break;
    } catch (_error) {
      error = _error;
    }
  }
  if (!((decryptInfo != null) && (decryptInfoNonce != null))) {
    throw GENERIC_ERROR;
  }
  decryptInfo = JSON.parse(decode_utf8(decryptInfo));
  senderPublicKey = b58decode(decryptInfo[DECRYPT_INFO_SENDER_FIELD]);
  messageInfoBox = b64decode(decryptInfo[DECRYPT_INFO_MESSAGE_INFO_FIELD]);
  messageInfo = nacl.crypto_box_open(messageInfoBox, decryptInfoNonce, senderPublicKey, userKeys.boxSk);
  messageInfo = JSON.parse(decode_utf8(messageInfo));
  messageKey = b64decode(messageInfo[MESSAGE_INFO_KEY_FIELD]);
  messageNonce = b64decode(messageInfo[MESSAGE_INFO_NONCE_FIELD]);
  return plaintext = {
    sender: b58encode(senderPublicKey),
    message: nacl.crypto_secretbox_open(b64decode(cipher[CIPHER_MESSAGE_FIELD]), messageNonce, messageKey)
  };
};

TAB_ENCRYPT = 'encrypt';

TAB_DECRYPT = 'decrypt';

TAB_CLOUD = 'cloud';

DisturbeApp = React.createClass({
  getInitialState: function() {
    return {
      userKeys: null,
      userData: null,
      selectedTab: TAB_ENCRYPT
    };
  },
  setPrivateKey: function(privateKey) {
    var userKeys;
    userKeys = nacl.crypto_box_keypair_from_raw_sk(privateKey);
    return this.setState({
      userKeys: userKeys
    });
  },
  setUserData: function(userData) {
    return this.setState({
      userData: {}
    });
  },
  onLogin: function(event) {
    return sendMessage(this.state.userKeys, {
      'method': 'get_userdata'
    }, (function(response) {
      return this.setUserData(response);
    }).bind(this), function(xhr) {
      return alert(xhr.responseText);
    });
  },
  changeTab: function(tab, event) {
    event.stopPropagation();
    event.preventDefault();
    if (tab !== this.state.selectedTab) {
      return this.setState({
        selectedTab: tab
      });
    }
  },
  render: function() {
    var activeIf, changeTabTo;
    activeIf = (function(tab) {
      return "" + (this.state.selectedTab === tab ? 'active' : '');
    }).bind(this);
    changeTabTo = (function(tab) {
      return this.changeTab.bind(this, tab);
    }).bind(this);
    return div(null, this.state.userKeys != null ? div(null, h1({
      className: 'large-bottom'
    }, 'curvech.at'), div({
      className: 'row'
    }, div({
      className: 'col-md-12'
    }, h3(null, 'Curve Profile'))), div({
      className: 'row'
    }, div({
      className: 'col-md-12 large-bottom'
    }, p(null, 'Anyone who has your curve ID can send messages that only you can decrypt.'), p(null, 'Spread your curve ID wide. The secret key you should never reveal.'))), CurveProfile({
      userKeys: this.state.userKeys
    }), ul({
      className: 'nav nav-tabs nav-justified',
      role: 'tablist',
      style: {
        marginTop: '2em',
        marginBottom: '1.2em'
      }
    }, li({
      className: activeIf(TAB_ENCRYPT)
    }, a({
      href: "#" + TAB_ENCRYPT,
      onClick: changeTabTo(TAB_ENCRYPT)
    }, i({
      className: 'fa fa-lock nav-icon'
    }), div({
      className: 'nav-label'
    }, 'Encrypt'))), li({
      className: activeIf(TAB_DECRYPT)
    }, a({
      href: "#" + TAB_DECRYPT,
      onClick: changeTabTo(TAB_DECRYPT)
    }, i({
      className: 'fa fa-unlock-alt nav-icon'
    }), div({
      className: 'nav-label'
    }, 'Decrypt'))), li({
      className: activeIf(TAB_CLOUD)
    }, a({
      href: "#" + TAB_CLOUD,
      onClick: changeTabTo(TAB_CLOUD)
    }, i({
      className: 'fa fa-cloud nav-icon'
    }), div({
      className: 'nav-label'
    }, 'Cloud')))), this.state.selectedTab === TAB_ENCRYPT ? EncryptMessage({
      userKeys: this.state.userKeys
    }) : this.state.selectedTab === TAB_DECRYPT ? DecryptMessage({
      userKeys: this.state.userKeys
    }) : void 0) : div({
      className: 'row'
    }, div({
      className: 'col-md-8 col-md-offset-2 large-bottom'
    }, h1({
      className: 'large-bottom'
    }, 'curvech.at'), GeneratePrivateKey({
      onGenerateKey: this.setPrivateKey
    }))));
  }
});

KeyProfile = React.createClass({
  getInitialState: function() {
    return {
      name: 'anonymous',
      email: '',
      social: ''
    };
  },
  componentDidMount: function() {
    return this.renderIdenticon(this.refs.identicon.getDOMNode());
  },
  renderIdenticon: function(elem) {
    return $(elem).identicon5({
      size: 80
    });
  },
  render: function() {
    return div(null, h3({
      className: 'media-heading'
    }, 'Public Key Profile'), div({
      className: 'media'
    }, span({
      className: 'pull-left',
      href: '#'
    }, div({
      className: 'media-object',
      ref: 'identicon'
    }, toHex(nacl.crypto_hash(this.props.publicKey)))), div({
      className: 'media-body'
    }, KeyProfileItem({
      name: 'Key',
      value: b58encode(this.props.publicKey, {
        iconClass: 'fa-key',
        editable: false
      })
    }), KeyProfileItem({
      name: 'Name',
      value: this.state.name,
      iconClass: 'fa-user',
      editable: true
    }), KeyProfileItem({
      name: 'Email',
      value: this.state.email,
      iconClass: 'fa-envelope-o',
      editable: true
    }), KeyProfileItem({
      name: 'Social',
      value: this.state.social,
      iconClass: 'fa-share-alt',
      editable: true
    }))));
  }
});

KeyProfileItem = React.createClass({
  componentDidMount: function() {
    var editable;
    editable = this.props.editable != null ? this.props.editable : false;
    if (editable) {
      return $(this.refs[this.props.name].getDOMNode()).editable({
        type: 'text',
        pk1: 1,
        title: 'enter name',
        showbuttons: false
      });
    }
  },
  render: function() {
    var icon, valueClass;
    icon = '';
    if (this.props.iconClass != null) {
      icon = i({
        className: "fa " + this.props.iconClass + " fa-fw text-muted"
      });
    }
    valueClass = '';
    if (this.props.editable) {
      valueClass = 'editable editable-click';
    }
    return div({
      className: 'user-profile-item'
    }, icon, span(null, "" + this.props.name + ": "), span({
      className: valueClass,
      ref: this.props.name,
      href: '#'
    }, this.props.value));
  }
});

EncryptMessage = React.createClass({
  getInitialState: function() {
    return {
      ciphertext: null
    };
  },
  clear: function() {
    return this.setState(this.getInitialState());
  },
  render: function() {
    return div(null, div({
      className: 'row'
    }, div({
      className: 'col-md-12 large-bottom'
    }, h3(null, 'Compose an encrypted message'), p(null, 'Only the owners of the public keys you specify will be able to decrypt it.'))), this.state.ciphertext == null ? ComposeMessage({
      userKeys: this.props.userKeys,
      onEncrypt: (function(ciphertext) {
        return this.setState({
          ciphertext: ciphertext
        });
      }).bind(this)
    }) : div(null, CipherTextarea({
      ciphertext: this.state.ciphertext
    }), div({
      className: 'row'
    }, div({
      className: 'col-md-12'
    }, p(null, 'Compose a ', a({
      onClick: this.clear,
      style: {
        cursor: 'pointer'
      }
    }, 'new message'))))));
  }
});

ComposeMessage = React.createClass({
  getInitialState: function() {
    return {
      recipients: [],
      message: ''
    };
  },
  getInvalidRecipientKeys: function() {
    var invalid, recipient, _i, _len, _ref1;
    invalid = [];
    _ref1 = this.state.recipients;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      recipient = _ref1[_i];
      if (!recipient.valid) {
        invalid.push(recipient.key);
      }
    }
    return invalid;
  },
  componentDidMount: function() {
    var innerInput, recipientsNode;
    recipientsNode = $(this.refs.recipients.getDOMNode());
    recipientsNode.tagsinput({
      tagClass: (function(key) {
        var labelClass, recipient, recipients;
        recipients = this.state.recipients.slice(0);
        recipient = {
          key: key
        };
        if (validPublicKey(key)) {
          labelClass = 'label label-primary';
          recipient.valid = true;
        } else {
          labelClass = 'label label-danger';
          recipient.valid = false;
        }
        recipients.push(recipient);
        this.setState({
          recipients: recipients
        });
        return labelClass;
      }).bind(this),
      trimValue: true
    });
    recipientsNode.on('itemRemoved', (function(event) {
      var index, recipient, recipients, _i, _len, _ref1;
      index = -1;
      _ref1 = this.state.recipients;
      for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
        recipient = _ref1[index];
        if (recipient.key === event.item) {
          break;
        }
      }
      if (index !== -1) {
        recipients = this.state.recipients.slice(0);
        recipients.splice(index, 1);
        return this.setState({
          recipients: recipients
        });
      }
    }).bind(this));
    innerInput = $(recipientsNode.tagsinput('input'));
    innerInput.addClass('form-control');
    return innerInput.css({
      width: ''
    });
  },
  changeMessage: function(event) {
    return this.setState({
      message: event.target.value
    });
  },
  encryptMessage: function(event) {
    var ciphertext, error, key, recipientKeys, recipientNode;
    event.preventDefault();
    recipientNode = $(this.refs.recipients.getDOMNode());
    recipientKeys = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = $(recipientNode).val().split(',');
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        key = _ref1[_i];
        _results.push(b58decode(key));
      }
      return _results;
    })();
    try {
      if (this.props.onEncrypt != null) {
        ciphertext = encryptMessage(this.props.userKeys, recipientKeys, this.state.message);
        return this.props.onEncrypt(ciphertext);
      }
    } catch (_error) {
      error = _error;
      return console.log(error);
    }
  },
  render: function() {
    var encryptButtonProps, error, invalidJoined, invalidRecipients;
    error = null;
    invalidRecipients = this.getInvalidRecipientKeys();
    if (invalidRecipients.length > 0) {
      invalidJoined = "" + (invalidRecipients.join(', '));
      if (invalidRecipients.length === 1) {
        error = "" + invalidJoined + " is not a valid curve ID";
      } else {
        error = "" + invalidJoined + " are not valid curve IDs";
      }
    }
    encryptButtonProps = {
      className: 'btn btn-lg btn-default',
      onClick: this.encryptMessage
    };
    if ((error != null) || this.state.recipients.length === 0) {
      encryptButtonProps.disabled = 'true';
    }
    return div(null, form({
      className: 'form-horizontal'
    }, error != null ? div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12'
    }, span({
      className: 'text-danger'
    }, error))) : void 0, div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12',
      style: {
        display: 'inline-block'
      }
    }, label({
      className: 'control-label'
    }, 'Recipients'), input({
      className: 'form-control',
      type: 'text',
      defaultValue: '',
      ref: 'recipients'
    }))), div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12',
      style: {
        display: 'inline-block'
      }
    }, label({
      className: 'control-label'
    }, 'Message'), textarea({
      className: 'form-control',
      value: this.state.message,
      placeholder: 'Type your message..',
      onChange: this.changeMessage,
      rows: 10
    }))), div({
      className: 'row'
    }, div({
      className: 'col-md-12 large-bottom'
    }, div({
      className: 'pull-right'
    }, button(encryptButtonProps, i({
      className: 'fa fa-fw fa-lg fa-lock'
    }), span(null, 'Encrypt')))))));
  }
});

CipherTextarea = React.createClass({
  render: function() {
    return form({
      className: 'form-horizontal'
    }, div({
      className: 'form-group large-bottom'
    }, div({
      className: 'col-xs-12',
      style: {
        display: 'inline-block'
      }
    }, label({
      className: 'control-label'
    }, 'Scrambled message'), textarea({
      className: 'form-control',
      value: this.props.ciphertext,
      placeholder: 'Type your message..',
      readOnly: true,
      rows: 10,
      style: {
        backgroundColor: 'white',
        cursor: 'auto'
      }
    }))));
  }
});

DecryptMessage = React.createClass({
  getInitialState: function() {
    return {
      ciphertext: '',
      error: null,
      plaintext: null
    };
  },
  clear: function() {
    return this.setState(this.getInitialState());
  },
  changeCiphertext: function(event) {
    return this.setState({
      ciphertext: event.target.value
    });
  },
  decryptMessage: function(event) {
    var error, plaintext;
    event.preventDefault();
    try {
      plaintext = decryptMessage(this.props.userKeys, this.state.ciphertext);
      plaintext.message = decode_utf8(plaintext.message);
      return this.setState({
        plaintext: plaintext
      });
    } catch (_error) {
      error = _error;
      this.setState({
        error: error.toString()
      });
      return console.log(error);
    }
  },
  render: function() {
    return div(null, div({
      className: 'row'
    }, div({
      className: 'col-md-12 large-bottom'
    }, h3(null, 'Decrypt a message'), p(null, 'You can only decrypt a message that was encrypted for your curve ID.'))), this.state.plaintext == null ? form({
      className: 'form-horizontal'
    }, this.state.error != null ? div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12'
    }, span({
      className: 'text-danger'
    }, this.state.error))) : void 0, div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12',
      style: {
        display: 'inline-block'
      }
    }, label({
      className: 'control-label'
    }, 'Scrambled message'), textarea({
      className: 'form-control',
      value: this.state.message,
      placeholder: 'Copy paste the scrambled message',
      onChange: this.changeCiphertext,
      rows: 10
    }))), div({
      className: 'row'
    }, div({
      className: 'col-md-12 large-bottom'
    }, button({
      className: 'btn btn-lg btn-default pull-right',
      onClick: this.decryptMessage
    }, i({
      className: 'fa fa-fw fa-lg fa-unlock-alt'
    }), span(null, 'Decrypt'))))) : div(null, Message({
      message: this.state.plaintext
    }), div({
      className: 'row'
    }, div({
      className: 'col-md-12'
    }, p(null, 'Decrypt ', a({
      onClick: this.clear,
      style: {
        cursor: 'pointer'
      }
    }, 'another message'))))));
  }
});

Message = React.createClass({
  render: function() {
    return form({
      className: 'form-horizontal'
    }, div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12',
      style: {
        display: 'inline-block'
      }
    }, label({
      className: 'control-label'
    }, 'From'), input({
      className: 'form-control',
      value: this.props.message.sender,
      readOnly: true,
      style: {
        backgroundColor: 'white',
        cursor: 'auto'
      }
    }))), div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12',
      style: {
        display: 'inline-block'
      }
    }, label({
      className: 'control-label'
    }, 'Message'), textarea({
      className: 'form-control',
      value: this.props.message.message,
      readOnly: true,
      rows: 10,
      style: {
        backgroundColor: 'white',
        cursor: 'auto'
      }
    }))));
  }
});

CurveProfile = React.createClass({
  componentDidMount: function() {
    return this.renderIdenticon(this.refs.identicon.getDOMNode());
  },
  renderIdenticon: function(elem) {
    return $(elem).identicon5({
      size: 120
    });
  },
  render: function() {
    return div(null, div({
      className: 'row'
    }, div({
      className: 'col-md-2'
    }, span({
      className: '',
      href: '#'
    }, span({
      className: 'text-muted'
    }, 'Fingerprint'), div({
      className: 'media-object',
      ref: 'identicon',
      style: {
        marginTop: '1em',
        borderStyle: 'solid',
        borderWidth: '0px',
        color: '#ccc'
      }
    }, toHex(nacl.crypto_hash(this.props.userKeys.boxPk))))), div({
      className: 'col-md-10'
    }, PublicKeyField({
      publicKey: this.props.userKeys.boxPk
    }), SecretKeyField({
      secretKey: this.props.userKeys.boxSk
    }))));
  }
});

PublicKeyField = React.createClass({
  getInitialState: function() {
    return {
      shown: false
    };
  },
  componentDidMount: function() {
    var clipboardButton;
    clipboardButton = $(this.refs.clipboardButton.getDOMNode());
    this.zeroClipboard = new ZeroClipboard(clipboardButton);
    return this.zeroClipboard.on('copy', this.onCopyPublicKey);
  },
  onCopyPublicKey: function(event) {
    var clipboard;
    clipboard = event.clipboardData;
    return clipboard.setData("text/plain", b58encode(this.props.publicKey));
  },
  onTweet: function(event) {
    var tweet_text;
    event.preventDefault();
    tweet_text = "cryptch.at is zero knowledge messaging with end to end " + ("encryption. My public key is " + (b58encode(this.props.publicKey)));
    return window.open("https://twitter.com/intent/tweet?text=" + tweet_text);
  },
  render: function() {
    var inputProps;
    inputProps = {
      type: 'text',
      readOnly: true,
      className: 'form-control text-monospace',
      placeholder: '',
      value: b58encode(this.props.publicKey),
      style: {
        backgroundColor: 'white',
        cursor: 'auto'
      }
    };
    return div({
      style: {
        paddingBottom: '1em'
      }
    }, label({
      className: 'control-label',
      style: {
        fontSize: '1.3em',
        marginTop: '0em'
      }
    }, "Curve ID"), div({
      className: 'input-group input-group-lg'
    }, input(inputProps), span({
      className: 'input-group-btn'
    }, button({
      className: 'btn btn-default',
      onClick: function(event) {
        return event.preventDefault();
      },
      ref: 'clipboardButton'
    }, i({
      className: 'fa fa-chain fa-lg'
    }))), span({
      className: 'input-group-btn'
    }, button({
      className: 'btn btn-default',
      onClick: this.onTweet
    }, i({
      className: 'fa fa-twitter fa-lg'
    })))));
  }
});

SecretKeyField = React.createClass({
  getInitialState: function() {
    return {
      shown: false
    };
  },
  onShow: function(event) {
    var hideKey, newState;
    event.preventDefault();
    newState = {
      shown: !this.state.shown
    };
    if (newState.shown) {
      hideKey = (function() {
        return this.setState({
          shown: false
        });
      }).bind(this);
      newState.timeoutId = window.setTimeout(hideKey, 5000);
    } else if (this.state.timeoutId != null) {
      window.clearTimeout(this.state.timeoutId);
    }
    return this.setState(newState);
  },
  render: function() {
    var classNames, inputProps, value;
    classNames = 'form-control text-monospace';
    if (this.state.shown) {
      value = b58encode(this.props.secretKey);
    } else {
      classNames += ' text-muted';
      value = '<< Hidden >>';
    }
    inputProps = {
      className: classNames,
      type: 'text',
      readOnly: true,
      placeholder: '',
      value: value,
      style: {
        backgroundColor: 'white',
        cursor: 'auto'
      }
    };
    return div({
      style: {
        paddingBottom: '1em'
      }
    }, label({
      className: 'control-label',
      style: {
        fontSize: '1.3em'
      }
    }, 'Secret Key'), div({
      className: 'input-group input-group-lg'
    }, input(inputProps), span({
      className: 'input-group-btn'
    }, button({
      className: 'btn btn-default',
      onClick: this.onShow
    }, this.state.shown ? 'Hide' : 'Show'))));
  }
});

GeneratePrivateKey = React.createClass({
  getInitialState: function() {
    return {
      validNewKey: false,
      email: '',
      password: ''
    };
  },
  generateKey: function(event) {
    var email, password, private_key, _base;
    event.preventDefault();
    email = this.state.email;
    password = this.state.password;
    private_key = credentialsToSecretKey(email, password);
    return typeof (_base = this.props).onGenerateKey === "function" ? _base.onGenerateKey(private_key) : void 0;
  },
  render: function() {
    var newIdentityButtonProps;
    newIdentityButtonProps = {
      className: 'btn btn-success pull-right',
      onClick: this.generateKey
    };
    if (!this.state.validNewKey) {
      newIdentityButtonProps.disabled = 'true';
    }
    return div({
      className: 'row'
    }, div({
      className: 'col-md-12'
    }, form({
      className: 'form-horizontal'
    }, div({
      className: 'row'
    }, div({
      className: 'col-md-12'
    }, h3(null, 'Derive your curve ID'), p(null, 'Your email and password are used to generate a unique pair of keys.'), p(null, 'The credentials do not leave your device and are never stored.'))), div({
      style: {
        marginTop: '1em'
      }
    }, InputField({
      type: 'text',
      label: 'Email',
      placeholder: 'Your email address',
      onChange: (function(email) {
        return this.setState({
          email: email
        });
      }).bind(this)
    }), InputField({
      type: 'password',
      label: 'Password',
      placeholder: 'Your strong password',
      onChange: (function(password) {
        return this.setState({
          password: password
        });
      }).bind(this)
    })), div({
      className: 'row'
    }, div({
      className: 'col-md-12'
    }, VerifyPassword({
      password: this.state.password,
      onUpdate: (function(valid) {
        return this.setState({
          validNewKey: valid
        });
      }).bind(this)
    }))), div({
      className: 'form-group'
    }, div({
      className: 'col-md-12 '
    }, button({
      className: 'btn btn-lg btn-success pull-right',
      onClick: this.generateKey
    }, 'Derive your curve ID'))))));
  }
});

VerifyPassword = React.createClass({
  getInitialState: function() {
    return {
      verifyPassword: ''
    };
  },
  componentDidUpdate: function() {
    return this.props.onUpdate(this.validPassword);
  },
  shouldComponentUpdate: function(nextProps, nextState) {
    return !(nextState.verifyPassword === this.state.verifyPassword && nextProps.password === this.props.password);
  },
  render: function() {
    var entropyClass, newKeyMessage, newKeyMessageClass, passwordStats;
    passwordStats = zxcvbn(this.props.password);
    this.validPassword = true;
    newKeyMessageClass = '';
    newKeyMessage = '';
    if (passwordStats.entropy < MINIMUM_PASSWORD_ENTROPY_BITS) {
      this.validPassword = false;
      newKeyMessage = 'Your password is not strong enough, it must to have at' + (" least " + MINIMUM_PASSWORD_ENTROPY_BITS + " bits of entropy.");
      newKeyMessageClass = 'text-danger';
    } else if (passwordStats.entropy < 110) {
      newKeyMessageClass = 'text-warning';
    } else {
      newKeyMessageClass = 'text-success';
    }
    entropyClass = newKeyMessageClass + ' password-entropy';
    if (this.props.password !== this.state.verifyPassword) {
      if (newKeyMessage === '') {
        this.validPassword = false;
        newKeyMessageClass = 'text-danger';
        newKeyMessage = 'Passwords do not match.';
      }
    } else if (newKeyMessage === '') {
      newKeyMessage = 'Everything is OK';
    }
    return div(null, div({
      className: 'row'
    }, div({
      className: 'col-md-12'
    }, div({
      className: 'password-entropy',
      style: {
        display: 'inline-block'
      }
    }, 'Entropy: ', span({
      className: entropyClass
    }, "" + passwordStats.entropy + " bits")))), div({
      className: "row"
    }, div({
      className: "col-md-12"
    }, p(null, "Your password needs to have high entropy to generate high quality keys."))), div({
      style: {
        marginBottom: "1em"
      }
    }, InputField({
      type: 'password',
      label: 'Check',
      onChange: (function(password) {
        return this.setState({
          verifyPassword: password
        });
      }).bind(this),
      placeholder: 'Optionally retype your password'
    })), div({
      className: 'row'
    }, div({
      className: 'col-md-12 large-bottom'
    }, p({
      className: newKeyMessageClass
    }, newKeyMessage))));
  }
});

InputField = React.createClass({
  onChange: function(event) {
    var _base;
    return typeof (_base = this.props).onChange === "function" ? _base.onChange(event.target.value) : void 0;
  },
  render: function() {
    var inputProps;
    inputProps = {
      type: this.props.type,
      placeholder: this.props.placeholder,
      value: this.props.value,
      className: 'form-control input-lg',
      onChange: this.onChange
    };
    if (this.props.value != null) {
      inputProps.value = this.props.value;
    }
    if (this.props.inputClass != null) {
      inputProps.className += ' ' + this.props.inputClass;
    }
    return div({
      className: 'form-group'
    }, div({
      className: 'col-xs-12',
      style: {
        display: 'inline-block'
      }
    }, label({
      className: 'control-label'
    }, this.props.label), input(inputProps)));
  }
});

$(function() {
  return React.renderComponent(DisturbeApp(), document.getElementById('app'));
});
